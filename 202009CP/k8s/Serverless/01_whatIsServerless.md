#### 1. 架构的演进  Evolution of architecture

* Traditional single application   传统单体应用

User -> Web server -> Database

随着业务的增长，这种最简单的单体应用架构很快就面临两个问题。首先，这里只有一 台服务器，如果这台服务器出现故障，例如硬件损坏，那么整个服务就会不可用;其次，业 务量变大之后，一台服务器的资源很快会无法承载所有流量。

解决这两个问题最直接的方法，就是在流量入口加一个负载均衡器，使单体应用同时部 署到多台服务器上，这样服务器的单点问题就解决了，与此同时，这个单体应用也具备了水 平伸缩的能力。


* Micro services  微服务

随着业务的进一步增长，更多的研发人员加入到团队中，共同在单体应用上开发特性。 由于单体应用内的代码没有明确的物理边界，大家很快就会遇到各种冲突，需要人工协调， 以及大量的 conflict merge 操作，研发效率直线下降。
因此大家开始把单体应用拆分成一个个可以独立开发、独立测试、独立部署的微服务应 用，服务和服务之间通过 API 通讯，如 HTTP、GRPC 或者 DUBBO。基于领域驱动 设计中 Bounded Context 拆分的微服务架构能够大幅提升中大型团队的研发效率。

应用从单体架构演进到微服务架构，从物理的角度看，分布式就成了默认选项，这时应 用架构师就不得不面对分布式带来的新挑战。在这个过程中，大家都会开始使用一些分布式 服务和框架，例如缓存服务 Redis、配置服务 ACM、状态协调服务 ZooKeeper、消息 服务 Kafka，还有通讯框架如 GRPC 或者 DUBBO，以及分布式追踪系统等。除分布式环境带来的挑战之外，微服务架构给运维也带来新挑战。研发人员原来只需要 运维一个应用，现在可能需要运维十个甚至更多的应用，这意味着安全 patch 升级、容量 评估、故障诊断等事务的工作量呈现成倍增长，这时，应用分发标准、生命周期标准、观测 标准、自动化弹性等能力的重要性也更加凸显。

* CloudNative 云原生架构

一个架构是否是云原生，就看这个架构是否是长在云上的，这是对“云原生”的简单理 解。这个“长在云上”不是简单地说用云的 IaaS 层服务，比如简单的 ECS、OSS 这些 基本的计算存储，而是应该理解成有没有使用云上的分布式服务，比如 Redis、Kafka 等， 这些才是直接影响到业务架构的服务。

另外两个不得不提的技术就是 Docker 和 Kubernetes，其中，前者标准化了应用分 发的标准，不论是 Spring Boot 写的应用，还是 Node.JS 写的应用，都以镜像的方式 分发;而后者在前者的技术上又定义了应用生命周期的标准，一个应用从启动到上线，到健 康检查，再到下线，都有了统一的标准。


在架构的演进过程中，研发运维人员逐渐把关注点从机器上移走，希望更多地由平台系 统管理机器，而不是由人去管理，这就是一个对 Serverless 的朴素理解。


#### Serverless的价值

虽然说是 Serverless，但 Server(服务器)是不可能真正消失的， Serverless 里这个 less 更确切地说，应该是开发者不用关心服务器的意思。这就好比现 代编程语言 Java 和 Python，开发不用手工分配和释放内存，但内存依然在哪里，只不 过交给垃圾收集器管理了。称一个能帮助你管理服务器的平台为 Serverless 平台，就好 比称呼 Java 和 Python 为 Memoryless 语言一样。

如果我们把目光放到今天这个云的时代，那么就不能狭义地把 Serverless 仅 仅理解为不用关心服务器。云上的资源除了服务器所包含的基础计算、网络、存储资源之外， 还包括各种类别的更上层的资源，例如数据库、缓存、消息等。

我们今天主流的使用云的方式，还是把物理服务器搬到云上，其他方面和以前区别不大；但不应该是未来我 们使用云的方式。我认为 Serverless 的愿景应该是 Write locally, compile to the cloud，即代码只关心业务逻辑，由工具和云去管理资源。


**核心优势**
* 不用关心服务器

管理一两台服务器可能不是什么麻烦的事情，管理数千甚至数万台服务器就没那么简单 了。任何一台服务器都可能出现故障，如何自动识别故障，摘除有问题的实例，这是 Serverless 平台必须具备的能力;此外，操作系统的安全补丁升级，需要做到不影响业务， 自动完成;日志和监控系统需要默认打通;系统的安全策略需要自动配置好以避免风险;当 资源不够时，需要能够自动分配资源并安装相关的代码和配置，等等。

* 自动弹性

今天的互联网应用都被设计成可伸缩架构，当业务有比较明显的高峰和低谷时，或者业 务有临时的容量需求时(比如营销活动)，Serverless 平台都能够及时且稳定地实现自动 弹性。为了实现这个能力，平台需要有非常强大的资源调度能力，以及对应用各项指标(如 load、并发)非常敏锐的感知能力。

* 按实际资源使用计费

Serverful 的方式使用云资源，是按占用而非使用计费的，例如用户在云上购买了三台 ECS，那么不管用户实际使用了这三台 ECS 多少的 CPU 和内存，他都需要支付这三 台 ECS 整体的费用。而在 Serverless 模式下，用户是按实际使用的资源付费的，例如 一个请求实际使用了一台 1core2g 规格资源 100ms 的时间，那么用户就只需要为该规 格的单价乘以时间(即 100ms)付费。类似的，用户如果用的是 Serverless 数据库，
那么就只需要为 query 实际消耗的资源，以及数据存储的资源付费。

* 更少的代码，更快的交付速度

基于 Serverless 架构的代码通常会重度使用后端的服务，将数据、状态管理等内容 从代码中分离出去;此外，更彻底的 FaaS 架构则把代码的 Runtime 也交给了平台管理。 这就意味着，同样的应用，Serverless 模式下的代码相比 Serverful 模式会少很多，因 此不论是从分发还是启动，都会更快。Serverless 平台也通常能够提供非常成熟的代码构 建发布、版本切换等特性，提升交付速度。



#### Serverless 架构

CNCF 对 Serverless 计算的定义，Serverless 架构应该是采用 FaaS(函数即服务)和 BaaS(后端服务)服务来解决问题的一种设计。


我们主要会采用计算、存储和消息通信等技术来设计架构，从可运维性、安全性、可靠性、 可扩展性、成本几个角度来衡量架构的优劣。


单体应用:所有的应用逻辑都在一个应用中完成，结合数据库，这种分层架构可 以快速实现一些复杂度较低的应用;

但是无论选择哪种架构，上 面提到的 Serverless 原生心智都有助于我们专注业务。比如:
* 是否需要自己购置服务器安装数据库，实现高可用、管理备份、升级版本等，还是可以 把这些事情交给托管的服务如 RDS;是否可使用表格存储、Serverless HBase 等 Serverless 数据库服务，实现按使用的弹性扩容缩容和付费;
* 单体应用是需要自己购置服务器运行，还是可以交给托管服务，如函数计算和 Serverless 应用引擎;
* 是否可以通过函数来实现轻量级微服务，依赖函数计算提供的负载均衡、自动伸缩、按 需付费、日志采集、系统监控等能力;
* 基于 Spring Cloud、Dubbo、HSF 等实现的微服务应用是否需要自己购置服务器 部署应用，管理服务发现，负载均衡，弹性伸缩，熔断，系统监控等，还是可以将这些 工作交给诸如 Serverless 应用引擎服务。



#### Serverless技术选型

* 产品及分层

最早提出 Serverless 的是 AWS，其在 Serverless 领域的旗舰产品是 function compute。

1. 容器实例： ECI
2. K8s容器编排： Serverless K8s
3. 应用： SAE    Serverless Application Engine
4. 函数： FC


* 函数计算

从用户角度，他需要做的只是编码，然后把代码上传 到函数计算中。这个时候还不会产生费用，只有到被调用的时候才有费用。调用的方式可以 是产品提供的 API/SDK，也可以通过一些事件源，比如阿里云的 OSS 的事件。比如用 户往 OSS 里的某一个 bucket 上传了一个文件，希望这个文件被自动处理;比如上传一 个 zip 包，希望能够自动解压到另外一个 bucket，这都是很典型的函数场景。

函数计算能够提供非常好的弹性能力，最终的费用是根据时长和内存数进行计费 的，如果调用量小的话，只会有很少的费用。并且它在语言方面也非常丰富，常用的 nodejs、php、python、java 都直接支持。同时提供自定义的运行环境，可以支持任意 的可执行的语言。

* 函数计算经典场景

1. Web 应用。可以是各种语言写的，这种可以使用 Serverless 框架新编写的程序， 也可以是已有的应用。比如小程序后端、或者发布到 API 市场的 API 后端应用等。

Java: Sprint boot
Python: Django, Flask
C#: ASP.Net
GO etc.

函数计算对客户的一个最大的价值，就是能够让用户只关注自己的业务逻辑开发，完全 不需要管理运维，诸如计算资源、网络设置等都不需要关心。在隔离性上提供 vm 级别的 隔离，保证用户在运行时的数据安全、运行时安全等;在可用性方面默认提供 3az 的高可 用架构，保证客户默认就是高可用的最佳实践架构;在弹性方面，可以做到毫秒级的弹性效 率，满足客户突发的流量冲击;在计费方面也非常灵活，真正按照用户的请求情况进行收费， 也支持对 long run 的应用更友好的预付费模式。

2. 对计算能力有很强的弹性诉求的应用。比如 AI 推理、音视频处理、文档转换等。
3. 事件驱动型的应用。比如通过其他阿里云产品驱动的场景、Web Hook、定时任务等。 函数计算已经与很多产品进行了打通，比如对象存储、表格存储、定时器、CDN、日志服务、云监控等，可以非常快速地组装出一些业务逻辑。



* SAE

SAE 是业内首款面向应用的 Serverless Paas 平台。这个产品以面向应用的视角， 帮助用户在不做任何修改的前提下把存量应用上到云端。在资源层，用户不再需要自己管理 和运维机器及集群，只需要关注自己应用所需要使用的规格以及实例数，不再需要关心底层 是虚机还是容器。
SAE 从资源层面提供计算资源、弹性、隔离性等能力，让用户只需要关注自己的应用。 在应用层，SAE 提供了监控、日志、微服务治理等能力，帮助用户解决应用可观测性和治 理需求。同时提供网络配置、流量控制能力，提供了和 CICD 良好的集成，用户可以使用 已有 CICD 部署到 SAE，比如 jenkins、云效等，可以说覆盖了应用上云的完整场景。



* ASK

最早的时候大家都把 Docker 镜像部署在虚机里，用户需要购买 ECS，然后部署镜 像，最后是网络的一些配置，比如 SLB、EIP 等。在这个过程中，用户需要自己完成部署 动作，扩容需要自己重复上面的动作，或者自己构建一套自动化脚本，相对来说成本和稳定 性都比较低。

之后有了 K8s 来帮大家解决容器编排的问题。这种标准化的方式确实大大提高了大家 的生产力。用户通过使用 deployment、service 等标准的 K8s 的方式进行编排，并进 行部署。但 K8s 的运维和管理还是相对比较复杂的，技能要求比较高，用户需要运维 ECS 以及通过 ECS 构建出来的 K8s。另外一个痛点是K8s 集群里的 ECS 先购买的，如果客户的负载有比较大的波动，就会出现比较多的资源浪费。虽然技术上也有 解决方案，比如 worker node 的弹性，但这对于初级用户来说，还是有比较高的复杂度。

在 ASK 的方案里，用户创建一个 ASK 集群，但不需要指定 任何 ECS 节点，然后通过标准的 K8s 容器编排、deployment 等部署镜像。ASK 会 根据用户的负载需求，自动在底层资源池构建需要的 POD 并进行弹性伸缩，用户不再需 要关心容量规划、ECS 机器运维、资源限制等 LaaS 层的问题，非常便利。

* ASK应用场景

首先可以用来跑在线业务，部署模式灵活，可以是 deployment、helm chart 等所有的 K8s 原生模式，特别是能够很好地应对突发流量， 极致弹性，可以在 30 秒完成 500 个容器实例的弹性。这样的弹性效率，可以很好地支 撑大数据计算类的任务，比如 Spark、Presto 等，也可以在需要的时候即时获取资源， 支撑 10000 以上 Pod 的规格，有效降低客户成本。

另外一个非常适合的场景是用来构建随需启动的构建任务，比如在 ASK 中运行 jenkins、Github-Runner 等。在有构建任务的时候，即时启动。没有任务的时候 0 消费， 成本做到最低。这里只是列出了一些例子的场景，实际上基于 ASK 的这个特性，用户可 以运行很多 K8s 原生的需要极致弹性的工作负载。






#### Serverless CICD   自动化CICD与安全灰度

当我们开发项目时，通常需要一个生产环境，然后需要预发环境，还有一些测试环境。 但通常每个环境都需要消耗资源和成本，以保持服务在线。而大多数时候非生产环境上的访 问量非常少，为此付出大量的成本很不划算。

但是，在 Serverless 架构中，我们可以为每位开发人员提供一个准生产环境。做 CI /CD 的时候，可以为每个功能分支创建独立的演示环境。
当团队成员在开发功能或者修复 bug 时，想要预览新功能，就可以立即部署，而不需 要在自己机器上模拟或者找其他同事协调测试环境的使用时间。

由于部署新环境变得很容易，对于自动化部署的要求就变高了。当然无论是否采用Serverless 架构，自动化部署都很重要。能否自动化地构建、部署和创建整个环境是判断 开发团队优秀与否的重要因素。在 serverless 场景，这种能力尤为重要，因为只有这样 才能充分利用平台的优势。
