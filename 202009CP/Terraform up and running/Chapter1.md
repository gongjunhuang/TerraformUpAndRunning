### 第一章：为什么用Terraform

代码能在你的机器上运行并不代表软件已经完成了，同理通过测试用例也不能表示已经大功告成；即便是code review中其他人已经认可你的代码也不是万事大吉。直到用户用上我们的软件我们才可以认为软件已经完成了。

软件交付包括使代码对顾客可用所需要的所有工作，例如让代码在生产环境服务器上运行，让代码能够应对中断和流量高峰，并且让代码能够应对黑客的攻击。在深入Terraform的细节之前，有必要退后一步，看看Terraform是如何在更大范围内适应软件交付的各种情况。本章将主要就这几个主题展开讨论：
* DevOps的兴起
* 什么是基础设施即代码？（IaC）
* IaC的好处
* Terraform是如何工作的？
* Terraform和其他IaC工具的对比

**DevOps的兴起**

在不太远的过去，如果你想开一家软件公司，你需要维护很多的硬件设备。你需要搭建很多机架，把服务器放进去，接线，安装冷却设备，建立冗余电源系统等等。所以通常需要一个专职的运维团队，主要负责管理硬件设备；另外一个开发团队主要负责开发软件。

传统的开发团队一般将应用开发好之后直接交给运维团队，如何部署并且运行这些应用就是运维团队的事情。大部分这些部署和运维的工作都是手动完成的。一部分手动工作是没法避免的，因为这些工作和连接物理硬件有关，例如架设服务器，接网线等。但是运维团队在和软件有关的很多工作也是手动在服务器上输入命令完成的，例如安装软件和它的依赖。

这种传统方式在一段时间内可以运行的很好，但是随着公司的扩大，逐渐会产生问题。事情一般会变成这样：因为通常是手动发布软件，随着服务器数量的增多，发布会变得缓慢、痛苦并且不可预测。运维团队偶尔会犯错，所以最后每个服务器的配置都和其他的服务器有微小的差异（*配置漂移问题*）。最终，bug的数量增加。开发摊开手说：“代码在我电脑上跑得没问题”。软件中断和停机变得越来越频繁。

运维团队对于每次发布之后都得处理问题到凌晨感到疲惫，所以把发布改成每周一次，到后来变成每月一次，每半年一次。每半年一次的发布之前的几个星期，开发团队尝试将他们的代码合到一起，导致大量的合并冲突。没人能让发布分支稳定下来，所有团队开始互相责怪，公司陷入停顿。

当前一种深刻的改变正在发生。相较于管理自己的数据中心，很多公司利用AWS，Azure等公有云服务的优势，把数据中心和服务器搬到云上。与以前在硬件上花很多时间相比，运维团队可以把所有精力花在软件上，使用Ansible、Puppet、docker和Terraform这些工具来工作。不同以前要手动搭服务器和接线，现在系统管理员已经开始写代码。

这种转变就导致开发团队和运维团队将大部分时间花在软件上，所以开发和运维团队之间的界限就越来越模糊。拥有一个独立的开发团队专职于应用开发以及一个运维团队负责运维代码仍然是合理的，但显而易见的是开发和运维需要更紧密地合作。这是DevOps时刻的来临。

DevOps不是团队名称或者工作的头衔或是一种科技，这是一种流程、思想和技术。每个人对DevOps都有自己的定义，在这本书中，我想这么去定义：
*DevOps的目标是使软件交付的效率大大提高*。

相比于传统代码合并的梦魇，当前可以不断集成代码并且让代码保持在一种可部署的状态。和以前一个月部署一次代码相比，现在每天可以部署代码多次，甚至每次提交代码之后都可以部署。和不断掉线和停机相比，你可以建立有弹性的可以自我恢复的系统，并且可以使用监控和告警系统来发现没法自我解决的问题。

经历过DevOps转型的公司的结果让人震惊。例如，Nordstorm发现在公司内进行DevOps实践之后，每月新特性交付的数量增加了一倍，能够减少50%的缺陷，减少60%的交付时间（产生想法到代码进入生产环境中），并且生产环境上的问题减少了60%~90%。自从惠普的激光打印固件部门展开DevOps实践之后，开发团队开发新特性的的时间从5%增加到40%并且能够减少40%的开销。Esty开展DevOps实践后，从之前充满压力的、很少的并经常导致中断的部署转变成每天部署25-50次，程序中断等情况相比以前也少很多。

DevOps理念有四个最核心的价值*CAMS*：文化、自动化、可量化和分享（Culture，Automation，Measurement，Sharing）。这本书并不是对DevOps做全面概述，所以我只会专注在其中一点：自动化。

目标是尽可能多的让软件交付过程自动化。这表示是要通过代码来管理基础设施，而不是在网页点击按钮或者手动输入一些命令。这就是基础设施即代码的含义。

**什么是基础设施即代码？**

基础设施即代码（IaC）背后的含义是用代码去定义、部署和更新基础设施。这代表一种思维方式的转变，即将操作的各个方面都视为软件 - 甚至于那些一般视为硬件的部分（如建立物理服务器等）。实际上，DevOps一个关键理念就是所有的都能用代码来管理，包括服务器、数据库、网络、日志文件、文档、自动化测试以及部署过程等。

IaC工具有四个广泛的类别：
* 临时脚本
* 配置管理工具
* 服务器模板工具
* 服务器预置工具

我们一样一样来看这些。

*临时脚本(Ad Hoc Scripts)*

使一切自动化最简单的方法是编写临时脚本。你可以将你之前手动做的工作分解成离散的步骤，使用自己最喜欢的脚本语言将这些步骤写成代码存放在脚本中，并在服务器上执行这个脚本。

举个例子，这里有个`setup-webserver.sh`的bash脚本，用来给服务器安装依赖，并从Git仓库中下载代码，然后作为Apache网络服务器启动：
```shell
# update the apt-get cache
sudo apt-get update

# Install PHP
sudo apt-get install -y php

# Install Apache
sudo apt-get install -y apache2

# Copy the code from git repo
sudo git clone https://github.com/brikis98/php-app.git /var/www/html/app

# Start apache
sudo service apache2 start
```

使用临时脚本的好处是可以用流行的、通用的编程语言并且可以用想要的任何方式写代码；坏处同样在这里。而专为IaC程序量身定制的工具则提供了简洁的API，可用于完成复杂的任务。如果用通用的编程语言，你需要为每一个任务写对应的代码。此外，为IaC设计的工具通常会为你的代码格式化成特定的风格；如果使用常见的编程语言，每个开发者都会使用自己的编程风格。对于一个几行的安装Apache的脚本，这两个问题并不算什么大事，但是如果你尝试用临时脚本去管理几十台服务器、数据库、负载均衡和网络配置等，那就很容易造成混乱。

如果你曾经维护过其他人的临时脚本仓库，你知道它几乎总会演变成一堆无法维护的乱糟糟的代码。临时脚本对小的、一次性的任务来说非常好，但如果你将要用代码管理所有的基础设施，那么你应该使用专门为IaC开发的工具。

*配置管理工具*

Chef、Puppet、Ansible和SaltStack就是所有的配置管理工具，意味着他们就是为了安装和管理现有服务器上的软件而设计的。例如，这里有个Ansible role名为`web-server.yml`用来配置apache服务器，功能和`setup-webserver.sh`一致：
```yaml
- name: Update the apt-get cache
  apt:
    update-cache: yes

- name: Install PHP
  apt:
    name: php

- name: Install Apache
  apt:
    name: apache2

- name: Copy the code from the repo
  git:
    repo=https://github.com/brikis98/php-app.git
    dest=/var/www/html/app

- name: Start apache
  service:
    name=apache2
    state=started
    enabled=yes
```

代码和Bash脚本很相似，但是用诸如Ansible这样的工具有很多好处：
* 编码规范： Ansible强制采用一致、可预测的结构，包括文档、文件布局、清晰的命名参数以及密码管理等。不同于每个开发者以不同的方式管理自己的临时脚本，大部分配置管理工具用一些规范让代码易于阅读。

* 幂等： 写一个可以成功运行一次的临时脚本是一件容易的事情，但是写一个能够一直成功运行的临时脚本就非常困难。每次你尝试在你的脚本中创建一个文件夹，就需要去先检查这个文件夹是否存在；每次在配置文件中加入一行，就需要先确认这行之前不存在；每次想要运行一个应用，需要先检查这个应用还没运行。代码无论执行多少次总能执行成功叫做*幂等代码*。为了使得bash脚本变得幂等，需要在脚本中加入很多代码，包括相当多的*if*语句。另一方面来说，很多Ansible方法，默认就是幂等的。在`web-server.yml`脚本中，只会在Apache没有安装的情况下安装，同时也只会在Apache服务没有开启的情况下启动Apache服务。

*分布式： 临时脚本是为了在本地、单个服务器上而写的；Ansible和其他配置管理工具专门用于管理大量的远程服务器。如果想要在五台服务器上执行`web-server.yml`脚本，首先创建一个`hosts`文件，把所有服务器的IP地址写入该文件中：
```
[webservers]
1.1.1.1
1.1.1.2
1.1.1.3
1.1.1.4
1.1.1.5
```

下一步就是编写如下的Ansible脚本`playbook.yml`：
```
- hosts: webservers
  roles:
    - web-server
```

最后就执行刚刚的脚本：

`> ansible-playbook playbook.yml`

这个命令会告诉Ansible平行的对五台服务器进行配置。也可以通过在脚本中增加一个`serial`参数来进行滚动部署，这会批量更新服务器，例如将`serial`设置为2，Ansible每次会更新两台服务器，直到五台全部更新完毕。在临时脚本中增加这种逻辑的话，代码量会成倍的增加。

*服务器模板工具*

另外一种发展迅速、可以当作配置管理的替代工具就是服务器模板工具，例如Docker、Packer和Vagrant。相较于启动很多服务器并在每个服务器上执行相同的代码，服务器模板工具背后的思想是创建服务器映像，以获得操作系统、软件、文件和其他相关细节的完全独立的“快照”。之后可以用其他IaC工具在服务器上安装这些镜像。

当前主要有两大类用于镜像的工具：
* 虚拟机： 虚拟机模拟整个电脑系统，包括硬件。运行一个虚拟机管理程序，例如VMWare、VirtualBox来虚拟化底层的CPU、内存、硬盘和网络等。这样做的好处是你在管理程序上运行的镜像只能看到虚拟出来的硬件，与宿主机和其他虚拟机是完全隔离的，并且在所有的环境上都能运行一致（例如自己的电脑、QA环境或是生产环境）。使用虚拟机的缺点就是这样做会消耗很多CPU、内存，并且启动花费时间也比较多。可以使用Packer和Vagrant来定义镜像。

* 容器： 容器模拟操作系统的用户空间。运行一个容器引擎，例如Docker或CoreOS rkt，来创建独立的进程、内存、挂载点和网络。这样做的优点是你在容器引擎上运行的容器只能看到它自己的用户空间，所以它和主机以及其他容器是隔离的，并且它在任何环境上都能以同样的方式运行。缺点就是同一个服务器上运行的所有容器共享该服务器的内核和硬件，所以容器的隔离不能像虚拟机那么安全。因为内核和硬件是共享的，所以容器可以以毫秒级的速度启动，并且启动几乎没有CPU和内存开销。可以通过Docker或CoreOS rkt来定义容器镜像。

以下是一个用packer定义镜像的模板，创建自定义镜像，可以运行在阿里云上：
```json
{
     "variables": {
       "access_key": "{{env `ALICLOUD_ACCESS_KEY`}}",
       "secret_key": "{{env `ALICLOUD_SECRET_KEY`}}"
     },
     "builders": [{
       "type":"alicloud-ecs",
       "access_key":"{{user `access_key`}}",
       "secret_key":"{{user `secret_key`}}",
       "region":"cn-beijing",
       "image_name":"packer_basic",
       "source_image":"ubuntu.vhd",
       "ssh_username":"root",
       "instance_type":"ecs.n1.tiny",
       "internet_charge_type":"PayByTraffic",
       "io_optimized":"true"
     }],
     "provisioners": [{
       "type": "shell",
       "inline": [
         "sudo apt-get update",
         "sudo apt-get install -y php"
         "sudo apt-get install -y apache2"
         "sudo git clone https://github.com/brikis98/php-app.git /var/www/html/app"
       ]
     }]
   }
```
从上面脚本中可以看出Packer模板定义了和`setup-webserver.sh`相同的Apache网络服务器，用了相同的bash代码。和bash脚本唯一的不同就是Packer模板中没有启动Apache服务（没有执行`sudo service apache2 start`这条命令）。这是因为服务器模板通常用来在虚机镜像中安装软件，只有当你运行这个镜像时（把镜像部署到服务器上）才会真正的运行这个软件。

通过运行`packer build webserver.json`来创建镜像，创建结束生成镜像之后，可以将镜像部署到所有的阿里云服务器上，当服务器启动之后，就可以开启Apache服务，每个服务器都将以同样的方式运行。

要注意的是每个服务器模板工具用途都略有不同。Packer通常用来创建在生产环境服务器上运行的镜像，比如在阿里云生产环境账号上用的虚机镜像。Vagrant通常用来创建在开发环境上使用的镜像，例如在Mac或者Windows电脑上运行的VitualBox镜像。Docker通常用来创建独立应用的镜像，可以把docker镜像运行在开发和生产环境上，只要在这些服务器上安装了docker引擎。一个常用模式是用packer创建一个安装了docker引擎的虚机镜像，把这个镜像部署到阿里云账号下的服务器集群中，再把docker容器部署到服务器集群中来运行目标应用。

不可变基础设施的背后思想都很一致：一旦部署了服务器，就不再对这个服务器进行任何更改。如果需要更新一些东西，比如需要部署新版本的代码，需要利用服务器模板重新创建一个虚机镜像，再把这个镜像部署到新的服务器上。因为服务器是不变的，所以很容易知道服务器上部署了什么。

*服务器预置工具*

配置管理工具和服务器模板工具定义了在每个服务器上运行的代码，而诸如Terraform、CloudFormation和OpenStack Head这些服务器预置工具就负责将服务器搭建起来。实际上，这些预置工具不仅仅可以创建服务器，还可以创建数据库、负载均衡、缓存、队列、监控、防火墙、路由表以及SSL证书等，基本上涵盖了基础设施的所有部分。

下面的代码就是通过Terraform部署一个服务器：
```
resource "alicloud_instance" "web" {
  image_id              = data.alicloud_images.default.images.0.id
  internet_charge_type  = "PayByBandwidth"

  instance_type        = data.alicloud_instance_types.c2g4.instance_types.0.id
  system_disk_category = "cloud_efficiency"
  security_groups      = [alicloud_security_group.default.id]
  instance_name        = "web"
  vswitch_id           = "vsw-abc12345"

  user_data = <<-EOF
              #!/bin/bash
              sudo service apache2 start
              EOF
}
```

如果对上面的语法不熟也不要担心，当前只需要关注两个参数：
* image_id: 这个参数指定了部署在服务器上的镜像ID，你可以把这个值设置为上一部分中通过packer执行`webserver.json`创建出来的镜像ID，其中包含了PHP，apache2以及应用的源代码。

* user_data: 这是服务器启动后就会运行的bash脚本，用这个代码来启动Apache服务。

换句话说，这块代码展示了服务器模板工具和服务器预置工具协同工作，这是不可变基础设施中的常见模式。

*基础设施即代码的优点*

现在你已经接触了IaC的不同部分，对此一个很好的问题就是：为什么要这么麻烦？为什么要学一堆新的语言和工具，这样就需要维护更多的代码，不会阻碍自己吗？

答案就是代码是非常强大的。作为将你的手动工作转换为代码的前期工作的回报，你在软件交付方面的能力能够得到极大的提高。详细情况请查阅[2020年devops状况报告](https://puppet.com/resources/report/2020-state-of-devops-report/)。

当你的基础设施使用代码定义的，你就可以用很多软件工程实践来极大提升软件交付效率，包括：
* 自服务： 大部分手动部署代码的团队都会有一个系统管理员团队（很可能只有一个人），他（们）是唯一知道如何成功部署并且能够访问生产环境的人。当公司发展起来之后这就成为了一个瓶颈。如果基础设施使用代码定义的，那么部署过程就能够自动化，开发就能在需要的时候自行开始部署流程。

* 安全快速： 如果部署是全自动化的，那么过程就会变得非常快，因为电脑执行部署步骤的速度比人快太多了，并且这个过程也会更安全，因为自动化的流程将更加一致，更具有重复性并且不容易出现人为错误。

* 文档化： 不同于仅仅由一两个系统管理员把控基础设施的状态，你可以在任何人都可以读取的源文件中展示基础设施的状态。换句话说，IaC就像文档一样，让团队中每个人都能理解代码是如何运行的。

* 版本控制： 可以把IaC代码存储在Git此类的版本控制仓库中，这样基础设施的所有历史改动都可以在代码提交日志中看到。这是调试问题的有力工具，任何时候出现问题，第一时间就应该去看代码提交日志，看是什么代码更改了基础设施，也可以简单通过回退代码把代码恢复到上一个正常运行的版本。

* 可验证： 如果基础设施使用代码定义的，对基础设施的每个更改，都可以进行代码审查，并进行自动化测试，同时新增代码必须通过静态检查工具，这些措施都能显著减少代码的缺陷。

* 可复用： 你可以将代码打包成可复用的模块，所以相比于每个环境、每个产品都从头开始写代码，你可以在已知的、已有文档的、已经过测试的基础上构建。

* 幸福感： 为什么使用IaC，还有一个非常重要但是经常被忽视的原因：幸福感。手动部署代码同时管理基础设施是非常重复且无趣的工作。开发和运维都讨厌这种工作，因为这没有挑战、没有创造性也没有辨识度。你可以几个月都非常完美的部署代码，但是没人关心这个，直到某天你搞砸了部署。这种工作方式充满压力而且让人不开心。IaC提供一种更好的替代，让机器做它适合做的事情：自动化；同时让开发者做他们适合做的事情：编程。

当前你可能已经理解为什么IaC是非常重要的，所以下个问题就是Terraform是不是适合你。为了回答这个问题，我先快速介绍Terraform是如何工作的，后续将把Terraform与其他几个流行IaC工具进行比较，比如Puppet、Ansible等。

*Terraform是如何工作的？*

这是有关Terraform是如何工作的高级概述，在一定程度上简化了。Terraform是由HashiCorp开源的自动化工具，由Go语言写的。Go语言编译成一个二进制文件，不出意外的称为，*terraform*。

你可以用在你电脑上或是其他任何服务器上使用这个二进制文件来部署基础设施，这个过程中不需要运行额外的基础设施。这是因为在后台，terraform二进制文件代表你对一个或多个云服务提供商（AWS、阿里云、Azure等）进行Api调用。

Terraform是怎么知道去调用什么API的？答案就是你编写Terraform配置，在这个文件中你定义了你想创建哪些基础设施。这些配置就是基础设施即代码中的代码。下面就是Terraform配置的例子：
```
resource "alicloud_vswitch" "vswitch-slb" {
  name              = var.vswitch_name
  vpc_id            = var.vpc_id
  cidr_block        = var.vswitch_cidr
  availability_zone = var.availability_zone
}
```
即使你之前没看过Terraform代码，阅读起来应该也不会困难。这个片段让Terraform向阿里云调用API来创建一个负载均衡。只要一种简单的语法，Terraform就可以让你跨越多个云服务商部署互连资源。

你可以把你的所有基础设施定义为Terraform配置文件 - 包括服务器、数据库、负载均衡等，并把文件提交到版本控制工具中。之后可以运行例如`terraform apply`这样的命令来部署基础设施。`terraform`二进制文件把你的代码解析为一系列的API调用并发给相应的云服务商，并使得这些API调用尽可能的高效。

当团队中有人想要对基础设施进行更改，不同于以往手动直接在服务器上进行更改，现在可以直接在Terraform配置文件上进行更改，通过自动化测试和代码审查校验这些更改，再把代码提交到版本控制工具当中，再运行`terraform apply`命令让terraform解析出相应的API调用来部署这些更改。


**Terraform和其他IaC工具的对比**

IaC是非常好的，但是选择用什么IaC工具的过程就不是这样了。很多IaC工具功能都是重叠的，一部分是开源的，也有一部分提供商业支持。除非每个工具都用过，不然对于该用什么标准来选择使用哪个工具还是不清楚的。

让人更加难以选择这些工具的原因是：大部分对于这些工具的比较只是简单罗列出这些工具的一般特性，看起来好像随便用哪个工具都能满足你的要求。尽管这在技术上是正确的，但是这对于我们的选择没有用处。这就像告诉一个编程新人，他可以用PHP，C语言来搭建一个网站，这在技术上没有问题，但是这样会忽略大量的信息，这些信息对于做出正确决策至关重要。

在下文中，我将会对当前主流的配置管理和预置工具进行详细的对比，包括Terraform、Ansible、SaltStack、Chef、Puppet、CloudFormation和OpenStack Heat。我的目的是通过解释为什么我的公司GruntWork选择使用Terraform，从而让你了解Terraform是不是一个正确的选择，以及某种程度上解释了我为什么写这本书。对于所有的技术选择来说，这是不断权衡和优先级的问题，因为你的优先级可能与我的不同，所以我希望分享我的思考过程可能帮助你做出适合你的选择。

这是主要权衡的几个方面：
* 配置管理 vs 预置服务
* 可变的基础设施 vs 不可变的基础设施
* 程序语言 vs 解释型语言
* 有主的 vs 无主的
* 有代理的 vs 无代理的
* 大的社区 vs 小的社区
* 成熟的 vs 前沿的

*配置管理vs预置*

如你之前看到的那样，Chef、Puppet、Ansible和SaltStack都是配置管理工具，而CloudFormation、Terraform以及OpenStack Heat都是服务预置工具。尽管区别不明显，因为配置管理工具在一定程度上也可以做一些服务预置工作（可以通过Ansible部署服务器），同时服务预置工具在一定程度上也可以做一些配置管理工作（在Terraform脚本中可以加入一些配置脚本），但总而言之，你总想找到最能满足自己需求的工具。

总体上来说，如果你使用例如Docker和Packer这样的服务器模板工具，大部分的配置管理需求已经被解决了。一旦你用Docker模板或是Packer模板创建好一个镜像，剩下的就是通过运行这些镜像来搭建基础设施。当进行到设施搭建的时候，服务器预置工具就是你最好的选择。

这就是说，如果你没有使用服务器模板工具，那么将配置管理工具和服务预置工具结合起来就是一个好的选择。例如，你可能想用Terraform来预置你的基础设施，然后用Chef来配置每个服务器。

*可变的基础设施vs不可变的基础设施*

诸如Chef、Puppet以及Ansible这些配置管理工具通常默认为是运用于可变的基础设施。如果你让Chef去安装新版本的OpenSSL，它就会在当前的服务器上更新软件并且更新就地发生。结果就是每个服务器最终都会和其他的服务器有些微的不同之处，导致难以诊断和复制的微小的配置bug（这和手动配置导致的配置偏移问题一样，尽管使用配置管理工具让这个问题不那么明显）。即使有自动化测试，这些bug也很难发现，当一个配置更改在测试环境上运行的没有问题，但是同样的更改在生产环境上可能就会有问题，因为生产环境的服务器可能累计了数个月的变更，而这些变更并没有反映在测试环境中。

如果用Terraform来部署Docker或者Packer创建出来的镜像，那么大部分的更改都能部署到一个新的服务器上。例如，如果想要部署一个新版本的OpenSSL，就用Packer来创建一个包含新版OpenSSL的镜像，并把镜像部署在新的服务器上，并将旧的服务器删除。因为每次部署用不可变的镜像部署在新服务器上，这种方法降低了配置偏移的可能性，更容易了解每台服务器上到底运行了什么软件，并且更容易在任何时间都可以部署含有任何版本的软件。这也能让自动化测试更有效率，因为测试环境和生产环境使用的镜像是一致的，所有测试环境中的结果能一致反映在生产环境上。

当然，也可以用配置管理工具来做不可变部署的工作，但这不是配置管理的常用方式，这是服务器预置工具的工作范畴。值得注意的是这种不可变的方式也有它自己的缺点。例如，为了一个小的更改而重新建立镜像并把镜像重新部署到所有服务器上会花费大量时间。此外，不变性仅仅持续到你实际运行镜像的时候。一旦服务器开始运行，它已经开始对硬盘做出一些更改，并且可能已经开始经历一定程度的配置偏移。

*程序语言vs解释型语言*

Chef和Ansible采用一个程序性的语言方式，你写的代码逐步指定了如何实现某些需求的最终状态。Terraform、CloudFormation、SaltStack、Puppet以及OpenStack Heat都鼓励使用一个声明式的方式，你写的代码指定了你想要的最终状态，而IaC工具本身则负责去实现这个最终状态。

这里看个例子来演示这两者的区别。想象你需要用镜像ID`imageId`来部署10台服务器（阿里云中的ECS实例，AWS中的EC2），下面就是简化的Ansible模板代码，用的就是程序性语言：
```yaml
- ecs:
    count: 10
    image: ami-40dsc128
    instance_type: g6e.xlarge
```

下面的就是一个简化的Terraform模板，实现和上面Ansible脚本一样的功能，用的是声明式语言方式:
```
resource "alicloud_instance" "web" {
  count         = 10
  image_id      = "ami-40dsc128"
  instance_type = "g6e.xlarge"
}
```

表面上看，这两种方式挺相似的，而且开始用Terraform或者Ansible来执行这些脚本的时候，他们的结果也很一致。有意思的是当你想对已有结构做出更改的时候会发生什么。

例如，如果流量增加，你想把服务器加到15台。用Ansible的话，你之前写的代码就没用了，如果仅仅将Ansible代码中的数量改为15并重新运行这块代码，那么就会部署15台新的服务器，最终会有25台服务器。所以你必须了解已经部署的基础设施然后再写一个新的脚本来加上五台服务器。
```yaml
- ecs:
    count: 5
    image: ami-40dsc128
    instance_type: g6e.xlarge
```

如果用解释型语言的话，因为要做的就是声明所需的最终状态，Terraform负责了解如何实现这个状态，与此同时，Terraform也会记录它之前创建的状态。因此，要增加5台服务器，你需要做的就是在之前脚本的基础上，将count的数量由10改为15。
```
resource "alicloud_instance" "web" {
  count         = 15
  image_id      = "ami-40dsc128"
  instance_type = "g6e.xlarge"
}
```

如果运行这个脚本，Terraform会意识到它已经创建了10台服务器，因此需要做的就是再创建5台。实际上，在执行脚本之前，可以使用`terraform plan`命令来预览即将发生的更改。

如果你想要部署一个不同版本的app，比如镜像id为ami-40dsc129，应该怎么做？用程序性语言的话，你之前写的Ansible之类的脚本就全都没用了，所以你需要写一个新的脚本来追踪之前创建的服务器并把每个服务器更新为新的版本。用Terraform这样的解释型语言的话，就只需要把之前的配置文件中的image_id改为新的ID：
```
resource "alicloud_instance" "web" {
  count         = 15
  image_id      = "ami-40dsc129"
  instance_type = "g6e.xlarge"
}
```

显而易见，这些例子都被简化了。Ansible允许你在部署新的服务器之前用标签来查看已有的服务器，但是对于用Ansible管理的每一类资源，如果都必须来手动管理已经存在的资源，这可能会变得非常复杂。这凸显了程序化语言的IaC工具的两大缺点：

* 程序性代码无法完全捕获基础设施的状态。仅仅看之前的几个Ansible文件不足以了解部署了什么，还需要了解文件执行的顺序。如果以不同的顺序执行这些脚本，那么得到的结果可能也不同，这从代码本身也看不出来。换句话说，要弄清楚Ansible或者Chef的代码，需要搞清楚代码历史上的所有变动。

* 程序性代码限制可复用性。因为不得不去考虑基础设施当前状态，所以极大限制程序性语言的可复用性。基础设施的状态是不断变化的，一星期之前可用的代码当前可能已经不可用，因为代码之前是为了当前已经不存在的基础设施而写的。

Terraform用的解释型编程语言让代码能够表明当前基础设施的最新状态。看一眼就可以知道当前部署哪些资源以及这些资源是如何配置的，不需要担心历史状态和执行时间。因为不需要考虑当前的状态，所以更容易创建可重用代码。只需要专注于描述你想要的最终状态，Terraform会自动弄清楚怎么从一个状态转移到另一个状态。这样做能让Terraform的代码小而易懂。

解释型的编程语言同样也有缺点。如果无法使用完整的编程语言，那么你的表达能力会受到限制。例如，想不停机部署这种类型的基础设置变更，就很难用解释型编程语言来表达。同样的是，如果不能够做一些for循环之类的逻辑操作，那么就很难创建通用的、可重用的代码。幸运的是，Terraform提供一些强有力的原型，例如输入参数、输出参数、模块、count、create_before_destroy、三元语法以及插补语法，甚至可以用解释型代码创建干净的、可复用的以及模块化的代码。第四章和第五章会讨论这些问题。


*有主的vs无主的*

Chef、Puppet和SaltStack默认需要一个master节点来保存所有基础设施以及分发更新的状态。每次想要更新基础设施的时候，用客户端向主节点发出新命令，然后主节点将更新推送到所有其他服务器，或是其他服务器从主节点拉取最新的更新。

用主节点有几个优势，首先，这是一个独立的中心，在这里你可以查看并管理基础设施的状态，许多配置管理工具都提供一个网络管理界面来让主服务器更容易的查看正在进行的工作。其次，一些主节点可以在后台持续运行并加强你的配置，这是因为如果有人在服务器上手动更改了一些配置，主节点可以回退这个更改来避免配置偏移。

但是，运行主节点有一些很严重的缺点：

* 额外的基础设施：为了运行一个主节点，不得不部署一个额外的服务器，或是一个服务器集群（为了实现高可用和扩展性）。

* 维护：对于主节点服务器，必须要去定期维护、升级、备份以及安装监控。

* 安全：必须要为客户端和主节点之间的通信、主节点和其他服务器之间的通信建立通道，这通常意味着开放额外的节点以及配置额外的认证系统，所有这些措施都增加了被攻击的可能。

Chef、Puppet以及SaltStack对于无主模式确实有不同程度的支持，在无主模式下，只需要在每个服务器上运行代理软件即可，一般是一个根据定期时间表来运行的任务, 然后用这个任务从版本控制仓库拉取最新的更新。这极大减少可变动部分的数量，但是正如下文会谈到的一样，这种方式仍然没有回答几个问题，特别是如何在开始阶段预置服务器以及在服务器上安装代理软件。

Ansible、CloudFormation、Heat以及Terraform默认都是无主的。更精确来说，其中一些是需要依赖于主节点，但是主节点已经是你正在使用的基础设施的一部分，并不需要额外的去管理。例如，Terraform通过使用云服务商的API于云服务商进行沟通，所以某种程度上来说，API服务器就是主节点服务器，除了这些服务器并不需要任何额外的基础设施或是额外的验证机制（只需要相应的API密钥）。Ansible通过SSH协议与每个服务器直连，所以不需要运行额外的基础设施或是额外的验证机制（只需要Ansible服务器上的SSH密钥）。

*有代理的vs无代理的*

Chef、Puppet以及SaltStack都要求在想要配置的服务器上安装代理软件（Chef Client、Puppet Agent以及Salt minion）。代理软件通常在服务器后台运行，负责为每台服务器安装最新的配置变更。

这种方式有几点缺陷：

* 初始化：如何在开始阶段预置服务器以及在服务器上安装代理软件？一些配置管理工具先预想有额外的流程已经帮忙处理好这些事情（例如首先用Terraform创建服务器，镜像中已经预装了需要的代理软件）；其他的配置管理工具通过特殊的初始化流程，可以使用一次性的命令调用云服务商的API，通过SSH协议来预置服务器并安装所需的代理软件。

* 维护：必须定期更新代理软件，如果有主服务器的话，请务必让其与主服务器保持同步。

* 安全：如果代理软件从主服务器拉取配置（如果没有主节点服务器的话就从其他服务器），那么就必须为每台服务器开放出站端口。如果主节点服务器向代理推送更新，那么就必须为每台服务器开放入站端口。在任一种情况下，你必须弄清楚如何对与之通信的服务器进行代理身份验证。所有这些措施都会增加受到攻击的风险。

重复一遍，Chef、Puppet以及SaltStack对于无主模式确实有不同程度的支持，但是这些支持总让人觉得是事后才想出的临时解决办法，并且不支持配置管理工具的全部功能。这就是为什么Chef、Puppet以及SaltStack这些工具的惯用或默认配置方式总是包括一个代理以及一个主节点。

所有这些额外的活动部件都会给你的基础架构引入大量的新的故障。每次你在凌晨3点拿到一个故障报告，你需要弄清楚这是你应用代码中的bug还是你IaC代码中的bug，又或者是配置管理工具客户端的bug，也可能是主节点服务器的原因，抑或是其他服务器和主节点服务器之间的通信问题...

Ansible、CloudFormation和Heat不要求你安装任何额外的代理软件。更精确来说，其中一些需要代理软件，但是这些软件已经安装在你的基础设施中。例如，AWS、Azure、Aliyun以及其他的云服务厂商负责在他们福利服务器上安装、管理和验证代理软件。作为Terraform的用户，你不需要关心这些步骤，你只需要发送命令然后云服务商的代理会在你的服务器上执行所有的命令。用Ansible的话，服务器上需要运行SSH，这个基本上在每台服务器上都有。

*大的社区vs小的社区*

当你选择一项技术的时候，你也选择了一个社区。在很多情况下，与技术本身固有的质量相比，项目周围的生态系统可能对你的体验产生更大的影响。社区决定多少人对项目做出贡献，有多少可用的插件、集成以及扩展，在网上寻求帮助是否容易以及是不是能够招聘到懂这个技术的员工。在不同社区之间做精确比较是非常困难的，但是可以通过在线搜索发现一些趋势。

*成熟的vs前沿的*

挑选技术栈的时候另一个关键因素就是技术成熟度。

| Name | Release Dates | Version |
| ---- | ---- | ---- |
| Puppet | 2005 | 7.1.0|
| Chef | 2009 |16.8.14 |
| CloudFormation | 2011 | ? |
| SaltStack | 2011 |v2019.2.8 |
| Ansible | 2012 |2.9 |
| Heat | 2012 |15.0.0-39 |
| Terraform | 2014 | 0.14.3|

需要明确的是，这个对比不是非常精确，因为不同的软件有各自不同的版本命名规则，但是一些趋势是明确的。在对比中，Terraform是最新的IaC工具，所以API可能存在不稳定的情况，出现bug也是相对正常。这就是Terraform最大的弱点：虽然短时间内它已经非常流行，但是使用一个不如其他IaC成熟，用Terraform这样新的、前沿的工具总要付出一些代价。*以阿里云为例，文档还是比较欠缺的*

*结论*

全部放在一起，下表展示了当前流行的IaC工具。注意这张表中展示的是这些IaC工具*最常用或默认*的使用方式，如本章前半段上文中讨论的，这些工具也足以应对其他配置管理场景的需求。

||Source|Cloud|Type|Infrastructure|Language|Agent|Master|Community|Maturity|
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Chef|Open|All|Config Mgmt|Mutable|Procedural|Yes|Yes|Large|High|
|Puppet|Open|All|Config Mgmt|Mutable|Declarative|Yes|Yes|Large|High|
|Ansible|Open|All|Config Mgmt|Mutable|Procedural|No|No|Large|Medium|
|SaltStack|Open|All|Config Mgmt|Mutable|Declarative|Yes|Yes|Medium|Medium|
|CloudFormation|Closed|All|Provisioning |Immutable|Declarative|No|No|Small|Medium|
|Heat|Open|All|Provisioning |Immutable|Declarative|No|No|Small|Low|
|Terraform|Open|All|Provisioning |Immutable|Declarative|No|No|Medium|Low|

在GruntWork，我们需要是一个开源的、云不可知的服务器预置工具，支持不可变基础设施，是一个声明式的语言以及无主和无代理的架构，同时有大的社区和成熟的代码。上表中可以看出，Terraform虽然不完美，但是也很契合我们的标准。
